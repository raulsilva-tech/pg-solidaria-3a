// Função isValidCPF (Sem alterações, está correta)
function isValidCPF(cpf) {
    cpf = cpf.replace(/[^\d]+/g, '');
    if (cpf.length !== 11 || !!cpf.match(/(\d)\1{10}/)) return false;
    let sum = 0;
    let remainder;
    for (let i = 1; i <= 9; i++) sum = sum + parseInt(cpf.substring(i - 1, i)) * (11 - i);
    remainder = (sum * 10) % 11;
    if ((remainder === 10) || (remainder === 11)) remainder = 0;
    if (remainder !== parseInt(cpf.substring(9, 10))) return false;
    sum = 0;
    for (let i = 1; i <= 10; i++) sum = sum + parseInt(cpf.substring(i - 1, i)) * (12 - i);
    remainder = (sum * 10) % 11;
    if ((remainder === 10) || (remainder === 11)) remainder = 0;
    if (remainder !== parseInt(cpf.substring(10, 11))) return false;
    return true;
}

// Função showFeedback (Sem alterações)
function showFeedback(inputElement, message) {
    // Remove feedback anterior
    let feedback = inputElement.nextElementSibling;
    if (feedback && feedback.classList.contains('invalid-feedback')) {
        feedback.remove();
    }

    // Adiciona novo feedback
    feedback = document.createElement('div');
    feedback.className = 'invalid-feedback';
    feedback.textContent = message;
    inputElement.parentNode.insertBefore(feedback, inputElement.nextSibling);
    inputElement.classList.add('is-invalid');
    inputElement.classList.remove('is-valid');
}


// --- CORREÇÃO 1: 'removeFeedback' não deve adicionar 'is-valid' ---
function removeFeedback(inputElement) {
    let feedback = inputElement.nextElementSibling;
    if (feedback && feedback.classList.contains('invalid-feedback')) {
        feedback.remove();
    }
    inputElement.classList.remove('is-invalid');
    // A classe 'is-valid' só será adicionada se a validação passar
    inputElement.classList.remove('is-valid'); 
}

// --- CORREÇÃO 2: Lógica de validação principal ajustada ---
function validateForm(form) {
    let isValid = true;
    const inputs = form.querySelectorAll('input[required], textarea[required]');

    inputs.forEach(input => {
        removeFeedback(input); // Apenas limpa o estado anterior
        let fieldIsValid = true; // Flag para este campo específico

        // Trata o CPF de forma especial PRIMEIRO
        if (input.id === 'cpf') {
            const cpfValue = input.value;
            // Se for obrigatório e estiver vazio
            if (input.required && !cpfValue) {
                isValid = false;
                fieldIsValid = false;
                showFeedback(input, 'O CPF é obrigatório.');
            } 
            // Se estiver preenchido, mas for inválido
            else if (cpfValue && !isValidCPF(cpfValue)) { 
                isValid = false;
                fieldIsValid = false;
                showFeedback(input, 'CPF inválido. Verifique o número.');
            }
        } 
        // Trata todos os outros campos com a validação padrão do HTML5
        else if (!input.checkValidity()) {
            isValid = false;
            fieldIsValid = false;
            showFeedback(input, input.validationMessage || 'Campo obrigatório ou formato incorreto.');
        }

        // Adiciona a classe 'is-valid' APENAS se o campo passou
        if (fieldIsValid) {
            input.classList.add('is-valid');
        }
    });

    return isValid;
}

// Função applyMasks (Sem alterações)
function applyMasks() {
    const cpfInput = document.getElementById('cpf');
    const telefoneInput = document.getElementById('telefone');
    const cepInput = document.getElementById('cep'); // Note: 'cepInput' não está sendo usado na sua função

    function applyMask(input, maskPattern) {
        if (!input) return;
        input.addEventListener('input', function(e) {
            let value = e.target.value.replace(/\D/g, ''); 
            let maskedValue = '';
            let k = 0;
            for (let i = 0; i < maskPattern.length; i++) {
                if (k >= value.length) break;
                if (maskPattern[i] === '#') {
                    maskedValue += value[k++];
                } else {
                    maskedValue += maskPattern[i];
                }
            }
            e.target.value = maskedValue;
        });
    }

    applyMask(cpfInput, '###.###.###-##');

    if (telefoneInput) {
        telefoneInput.addEventListener('input', function(e) {
            let value = e.target.value.replace(/\D/g, '');
            let mask = (value.length > 10) ? '(##) #####-####' : '(##) ####-####';
            let maskedValue = '';
            let k = 0;
            for (let i = 0; i < mask.length; i++) {
                if (k >= value.length) break;
                if (mask[i] === '#') {
                    maskedValue += value[k++];
                } else {
                    maskedValue += mask[i];
                }
            }
            e.target.value = maskedValue;
        });
    }
}

// --- CORREÇÃO 3: Chamar a função applyMasks ---
// Adiciona as máscaras assim que o conteúdo da página carregar
document.addEventListener('DOMContentLoaded', function() {
    applyMasks();
});

// Listener de submit (Sem alterações)
document.addEventListener('submit', function(e) {
    const form = e.target.closest('#cadastro-form');
    if (form) {
        e.preventDefault();
        if (validateForm(form)) {
            alert('Formulário validado com sucesso! (Simulação de envio)');
            form.reset();
            // Limpa as classes de validação após o reset
            form.querySelectorAll('.is-valid, .is-invalid').forEach(el => {
                el.classList.remove('is-valid', 'is-invalid');
            });
        } else {
            alert('Por favor, corrija os erros no formulário.');
        }
    }
});